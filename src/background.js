

console.log('loading');

// ======================================================================================

const MQ = (() => {

  const hardcodeScriptEntries = [


    {
      "antifeatures": {},
      "author": "You",
      "blockers": [],
      "connects": [],
      "copyright": null,
      "description": "try to take over the world!",
      "description_i18n": {},
      "downloadURL": null,
      "enabled": true,
      "evilness": 0,
      "excludes": [],
      "fileURL": null,
      "grant": [
        "none"
      ],
      "header": "// ==UserScript==\n// @name         New Userscript 1\n// @namespace    Violentmonkey Scripts\n// @version      2024-01-02\n// @description  try to take over the world!\n// @author       You\n// @match        https://example.org/*\n// @icon         data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\n// @grant        none\n// ==/UserScript==",
      "homepage": null,
      "icon": "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
      "icon64": null,
      "includes": [],
      "lastModified": 1704244040741,
      "matches": [
        "https://example.org/*"
      ],
      "name": "New Userscript 1",
      "name_i18n": {},
      "namespace": "Violentmonkey Scripts",
      "options": {
        "check_for_updates": true,
        "comment": null,
        "compat_foreach": false,
        "compat_metadata": false,
        "compat_powerful_this": null,
        "compat_wrappedjsobject": false,
        "compatopts_for_requires": true,
        "noframes": null,
        "override": {
          "merge_connects": true,
          "merge_excludes": true,
          "merge_includes": true,
          "merge_matches": true,
          "orig_connects": [],
          "orig_excludes": [],
          "orig_includes": [],
          "orig_matches": [
            "https://example.org/*"
          ],
          "orig_noframes": null,
          "orig_run_at": "document-idle",
          "use_blockers": [],
          "use_connects": [],
          "use_excludes": [],
          "use_includes": [],
          "use_matches": []
        },
        "run_at": null,
        "sandbox": null,
        "tab_types": null,
        "unwrap": null,
        "user_modified": 1704244040748
      },
      "position": 1,
      "supportURL": null,
      "sync": {
        "imported": 9
      },
      "updateURL": null,
      "uuid": "ce6a2ec5-fb09-4de9-853a-e0a70c5da20e",
      "version": "2024-01-02",
      "webRequest": null,
      "userscript": true,
      "requires": [],
      "resources": [],
      "code": "// ==UserScript==\n// @name         New Userscript 1\n// @namespace    Violentmonkey Scripts\n// @version      2024-01-02\n// @description  try to take over the world!\n// @author       You\n// @match        https://example.org/*\n// @icon         data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\n// @grant        none\n// ==/UserScript==\n\n(function() {\n    'use strict';\n\n    // Your code here...\n    console.log(2030);\n    console.log(2031);\n})();",
      "contexter": false,
      "temp_connects": [],
      "storage_key_count": 0,
      "positionof": 1
    },



    {
      "antifeatures": {},
      "author": "You",
      "blockers": [],
      "connects": [],
      "copyright": null,
      "description": "try to take over the world!",
      "description_i18n": {},
      "downloadURL": null,
      "enabled": true,
      "evilness": 0,
      "excludes": [],
      "fileURL": null,
      "grant": [
        "none"
      ],
      "header": "// ==UserScript==\n// @name         New Userscript 2\n// @namespace    Violentmonkey Scripts\n// @version      2024-01-02\n// @description  try to take over the world!\n// @author       You\n// @match        http://example.com/*\n// @icon         data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\n// @grant        none\n// ==/UserScript==",
      "homepage": null,
      "icon": "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
      "icon64": null,
      "includes": [],
      "lastModified": 1704244050741,
      "matches": [
        "http://example.com/*"
      ],
      "name": "New Userscript 2",
      "name_i18n": {},
      "namespace": "Violentmonkey Scripts",
      "options": {
        "check_for_updates": true,
        "comment": null,
        "compat_foreach": false,
        "compat_metadata": false,
        "compat_powerful_this": null,
        "compat_wrappedjsobject": false,
        "compatopts_for_requires": true,
        "noframes": null,
        "override": {
          "merge_connects": true,
          "merge_excludes": true,
          "merge_includes": true,
          "merge_matches": true,
          "orig_connects": [],
          "orig_excludes": [],
          "orig_includes": [],
          "orig_matches": [
            "http://example.com/*"
          ],
          "orig_noframes": null,
          "orig_run_at": "document-idle",
          "use_blockers": [],
          "use_connects": [],
          "use_excludes": [],
          "use_includes": [],
          "use_matches": []
        },
        "run_at": null,
        "sandbox": null,
        "tab_types": null,
        "unwrap": null,
        "user_modified": 1704244050748
      },
      "position": 1,
      "supportURL": null,
      "sync": {
        "imported": 9
      },
      "updateURL": null,
      "uuid": "dc50ca86-42fc-4df8-949c-90f7e68acee0",
      "version": "2024-01-02",
      "webRequest": null,
      "userscript": true,
      "requires": [],
      "resources": [],
      "code": "// ==UserScript==\n// @name         New Userscript 2\n// @namespace    Violentmonkey Scripts\n// @version      2024-01-02\n// @description  try to take over the world!\n// @author       You\n// @match        http://example.com/*\n// @icon         data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\n// @grant        none\n// ==/UserScript==\n\n(function() {\n    'use strict';\n\n    // Your code here...\n    console.log(7020);\n    console.log(7021);\n})();",
      "contexter": false,
      "temp_connects": [],
      "storage_key_count": 0,
      "positionof": 1
    },


    {
      "antifeatures": {},
      "author": "Roger Federer <https://userscripts-site.org/users/371179> & Davide <iFelix18@protonmail.com>",
      "blockers": [],
      "connects": [
        "userscripts-site.org"
      ],
      "copyright": "2023, Roger Federer (https://userscripts-site.org/users/371179); 2021, Davide (https://gitstore.com/iFelix18)",
      "description": "Adds various features and improves the Greasy Fork experience",
      "description_i18n": {
        "de": "Fügt verschiedene Funktionen hinzu und verbessert das Greasy Fork-Erlebnis",
        "es": "Agrega varias funciones y mejora la experiencia de Greasy Fork",
        "fr": "Ajoute diverses fonctionnalités et améliore l'expérience Greasy Fork",
        "it": "Aggiunge varie funzionalità e migliora l'esperienza di Greasy Fork",
        "ja": "Greasy Forkの体験を向上させる様々な機能を追加",
        "ko": "Greasy Fork 경험을 향상시키고 다양한 기능을 추가",
        "ru": "Добавляет различные функции и улучшает работу с Greasy Fork",
        "zh_CN": "添加各种功能并改善 Greasy Fork 体验",
        "zh_TW": "加入多種功能並改善Greasy Fork的體驗"
      },
      "downloadURL": null,
      "enabled": false,
      "evilness": 0,
      "excludes": [],
      "fileURL": "https://update.userscripts-site.org/scripts/473830/Greasy%20Fork%2B%2B.user.js",
      "grant": [
        "GM.deleteValue",
        "GM.getValue",
        "GM.notification",
        "GM.registerMenuCommand",
        "GM.setValue",
        "unsafeWindow"
      ],
      "header": "// ==UserScript==\n// @name               Greasy Fork++\n// @namespace          https://gitstore.com/iFelix18\n// @version            3.2.30\n// @author             Roger Federer <https://userscripts-site.org/users/371179> & Davide <iFelix18@protonmail.com>\n// @icon               https://www.google.com/s2/favicons?domain=https://userscripts-site.org\n// @description        Adds various features and improves the Greasy Fork experience\n// @description:de     Fügt verschiedene Funktionen hinzu und verbessert das Greasy Fork-Erlebnis\n// @description:es     Agrega varias funciones y mejora la experiencia de Greasy Fork\n// @description:fr     Ajoute diverses fonctionnalités et améliore l'expérience Greasy Fork\n// @description:it     Aggiunge varie funzionalità e migliora l'esperienza di Greasy Fork\n// @description:ru     Добавляет различные функции и улучшает работу с Greasy Fork\n// @description:zh-CN  添加各种功能并改善 Greasy Fork 体验\n// @description:zh-TW  加入多種功能並改善Greasy Fork的體驗\n// @description:ja     Greasy Forkの体験を向上させる様々な機能を追加\n// @description:ko     Greasy Fork 경험을 향상시키고 다양한 기능을 추가\n// @copyright          2023, Roger Federer (https://userscripts-site.org/users/371179); 2021, Davide (https://gitstore.com/iFelix18)\n// @license            MIT\n// @require            https://fastly.jsdelivr.net/gh/sizzlemctwizzle/GM_config@06f2015c04db3aaab9717298394ca4f025802873/gm_config.min.js\n// @require            https://fastly.jsdelivr.net/npm/@violentmonkey/shortcut@1.4.1/dist/index.min.js\n// @require            https://fastly.jsdelivr.net/gh/roger810/userscript-supports@3fa07109efca28a21094488431363862ccd52d7c/library/WinComm.min.js\n// @match              *://userscripts-site.org/*\n// @match              *://myscripts-site.org/*\n// @connect            userscripts-site.org\n// @compatible         chrome\n// @compatible         edge\n// @compatible         firefox\n// @compatible         safari\n// @compatible         brave\n// @grant              GM.deleteValue\n// @grant              GM.getValue\n// @grant              GM.notification\n// @grant              GM.registerMenuCommand\n// @grant              GM.setValue\n// @grant              unsafeWindow\n// @run-at             document-start\n// @inject-into        content\n// ==/UserScript==",
      "homepage": null,
      "icon": "https://www.google.com/s2/favicons?domain=https://userscripts-site.org",
      "icon64": null,
      "includes": [],
      "lastModified": 1699862093311,
      "matches": [
        "*://userscripts-site.org/*",
        "*://myscripts-site.org/*"
      ],
      "name": "Greasy Fork++",
      "name_i18n": {},
      "namespace": "https://gitstore.com/iFelix18",
      "options": {
        "check_for_updates": true,
        "comment": null,
        "compat_foreach": false,
        "compat_metadata": false,
        "compat_powerful_this": null,
        "compat_wrappedjsobject": false,
        "compatopts_for_requires": true,
        "noframes": null,
        "override": {
          "merge_connects": true,
          "merge_excludes": true,
          "merge_includes": true,
          "merge_matches": true,
          "orig_connects": [
            "userscripts-site.org"
          ],
          "orig_excludes": [],
          "orig_includes": [],
          "orig_matches": [
            "*://userscripts-site.org/*",
            "*://myscripts-site.org/*"
          ],
          "orig_noframes": null,
          "orig_run_at": "document-start",
          "use_blockers": [],
          "use_connects": [],
          "use_excludes": [],
          "use_includes": [],
          "use_matches": []
        },
        "run_at": null,
        "sandbox": "DOM",
        "tab_types": null,
        "unwrap": null,
        "user_modified": null
      },
      "position": 9,
      "supportURL": null,
      "sync": {
        "imported": 9
      },
      "updateURL": null,
      "uuid": "0d334a55-7003-4d2e-8625-8ea95c6df28c",
      "version": "3.2.30",
      "webRequest": null,
      "userscript": true,
      "requires": [
        {
          "display_url": "https://fastly.jsdelivr.net/gh/sizzlemctwizzle/GM_config@06f2015c04db3aaab9717298394ca4f025802873/gm_config.min.js",
          "abs_url": "https://update.userscripts-site.org/scripts/473830",
          "unsafe_url": "https://fastly.jsdelivr.net/gh/sizzlemctwizzle/GM_config@06f2015c04db3aaab9717298394ca4f025802873/gm_config.min.js",
          "url": "https://fastly.jsdelivr.net/gh/sizzlemctwizzle/GM_config@06f2015c04db3aaab9717298394ca4f025802873/gm_config.min.js",
          "data": {
            "length": 13189
          },
          "ts": 1704294653066,
          "mimetype": "text/javascript",
          "editable": true,
          "viewable": true
        },
        {
          "display_url": "https://fastly.jsdelivr.net/npm/@violentmonkey/shortcut@1.4.1/dist/index.min.js",
          "abs_url": "https://update.userscripts-site.org/scripts/473830",
          "unsafe_url": "https://fastly.jsdelivr.net/npm/@violentmonkey/shortcut@1.4.1/dist/index.min.js",
          "url": "https://fastly.jsdelivr.net/npm/@violentmonkey/shortcut@1.4.1/dist/index.min.js",
          "data": {
            "length": 5689
          },
          "ts": 1704294653067,
          "mimetype": "text/javascript",
          "editable": true,
          "viewable": true
        },
        {
          "display_url": "https://fastly.jsdelivr.net/gh/roger810/userscript-supports@3fa07109efca28a21094488431363862ccd52d7c/library/WinComm.min.js",
          "abs_url": "https://update.userscripts-site.org/scripts/473830",
          "unsafe_url": "https://fastly.jsdelivr.net/gh/roger810/userscript-supports@3fa07109efca28a21094488431363862ccd52d7c/library/WinComm.min.js",
          "url": "https://fastly.jsdelivr.net/gh/roger810/userscript-supports@3fa07109efca28a21094488431363862ccd52d7c/library/WinComm.min.js",
          "data": {
            "length": 1491
          },
          "ts": 1704294653067,
          "mimetype": "text/javascript",
          "editable": true,
          "viewable": true
        }
      ],
      "resources": [],
      "code": "// ==UserScript==\n// @name               Greasy Fork++\n// @namespace          https://gitstore.com/iFelix18\n// @version            3.2.30\n// @author             Roger Federer <https://userscripts-site.org/users/371179> & Davide <iFelix18@protonmail.com>\n// @icon               https://www.google.com/s2/favicons?domain=https://userscripts-site.org\n// @description        Adds various features and improves the Greasy Fork experience\n// @description:de     Fügt verschiedene Funktionen hinzu und verbessert das Greasy Fork-Erlebnis\n// @description:es     Agrega varias funciones y mejora la experiencia de Greasy Fork\n// @description:fr     Ajoute diverses fonctionnalités et améliore l'expérience Greasy Fork\n// @description:it     Aggiunge varie funzionalità e migliora l'esperienza di Greasy Fork\n// @description:ru     Добавляет различные функции и улучшает работу с Greasy Fork\n// @description:zh-CN  添加各种功能并改善 Greasy Fork 体验\n// @description:zh-TW  加入多種功能並改善Greasy Fork的體驗\n// @description:ja     Greasy Forkの体験を向上させる様々な機能を追加\n// @description:ko     Greasy Fork 경험을 향상시키고 다양한 기능을 추가\n// @copyright          2023, Roger Federer (https://userscripts-site.org/users/371179); 2021, Davide (https://gitstore.com/iFelix18)\n// @license            MIT\n// @require            https://fastly.jsdelivr.net/gh/sizzlemctwizzle/GM_config@06f2015c04db3aaab9717298394ca4f025802873/gm_config.min.js\n// @require            https://fastly.jsdelivr.net/npm/@violentmonkey/shortcut@1.4.1/dist/index.min.js\n// @require            https://fastly.jsdelivr.net/gh/roger810/userscript-supports@3fa07109efca28a21094488431363862ccd52d7c/library/WinComm.min.js\n// @match              *://userscripts-site.org/*\n// @match              *://myscripts-site.org/*\n// @connect            userscripts-site.org\n// @compatible         chrome\n// @compatible         edge\n// @compatible         firefox\n// @compatible         safari\n// @compatible         brave\n// @grant              GM.deleteValue\n// @grant              GM.getValue\n// @grant              GM.notification\n// @grant              GM.registerMenuCommand\n// @grant              GM.setValue\n// @grant              unsafeWindow\n// @run-at             document-start\n// @inject-into        content\n// ==/UserScript==\n\n/* global GM_config, VM, GM, WinComm */\n\n/**\n * @typedef { typeof import(\"./library/WinComm.js\")  } WinComm\n */\n\nconsole.log('hello my world');\n",
      "origin": {
        "id": "473830",
        "token": "gf",
        "meta_url": true,
        "url": "https://userscripts-site.org/scripts/473830",
        "issue_url": "https://userscripts-site.org/scripts/473830/feedback",
        "code_url": "https://userscripts-site.org/scripts/473830/code"
      },
      "contexter": false,
      "temp_connects": [],
      "storage_key_count": 1,
      "file_url": "https://update.userscripts-site.org/scripts/473830/Greasy%20Fork%2B%2B.user.js",
      "positionof": 21
    }



  ];

  const hardcodeStorages = {
    "0d334a55-7003-4d2e-8625-8ea95c6df28c": {
      "ts": 1704294653068,
      "data": {
        "firstUse": "bfalse"
      }
    }

  }

  const hardcodeExtenalScripts = {
    '0d334a55-7003-4d2e-8625-8ea95c6df28c': [
      {
        "ts": 1704294653066,
        "url": "https://fastly.jsdelivr.net/gh/sizzlemctwizzle/GM_config@06f2015c04db3aaab9717298394ca4f025802873/gm_config.min.js",
        "data": {
          "content": "/**\n * Minified by jsDelivr using Terser v5.17.1.\n * Original file: /gh/sizzlemctwizzle/GM_config@06f2015c04db3aaab9717298394ca4f025802873/gm_config.js\n *\n * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files\n */\n// @copyright     2009+, Mike Medley (https://gitstore.com/sizzlemctwizzle)\n// @license       LGPL-3.0-or-later; https://raw.gitstoreusercontent.com/sizzlemctwizzle/GM_config/master/LICENSE\nwindow.abc101=()=>console.log(101);\n//# sourceMappingURL=/sm/d46e075816aeea49f6f059f4b2da49d5ab175f4581f0c81a819d9ac4823a7bd7.map",
          "meta": "text/javascript"
        }
      },
      {
        "ts": 1704294653067,
        "url": "https://fastly.jsdelivr.net/gh/roger810/userscript-supports@3fa07109efca28a21094488431363862ccd52d7c/library/WinComm.min.js",
        "data": {
          "content": "/**\n * Minified by jsDelivr using Terser v5.19.2.\n * Original file: /gh/roger810/userscript-supports@3fa07109efca28a21094488431363862ccd52d7c/library/WinComm.js\n *\n * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files\n */\n!function(n){\"use strict\";const o=new Map;let e=1;n.createInstance=n=>({hook:(o,e,i=location.origin)=>{window[o]?window.removeEventListener(\"message\",window[o],false):window[o]=n=>window[o].handleEvent(n),window[o].handleEvent=o=>{if(!o||o.origin!==i)return;const t=o.data;if(t.communicationId!==n)return;const a=e[t.action];\"function\"==typeof a&&a(t,o)},window.addEventListener(\"message\",window[o],false)},unhook:(n,o=true)=>{window.removeEventListener(\"message\",window[n],false),o&&(window[n]=null)},send:(o,e,i=location.origin)=>{window.postMessage({communicationId:n,action:o,data:e},i)},request:(i,t,a=location.origin)=>new Promise((s=>{e>8e5&&(e%=100);const d=e++;o.set(d,s),window.postMessage({communicationId:n,callbackId:d,action:i,data:t},a)})),response:(o,e,i)=>{o.source.postMessage({communicationId:n,action:e,data:i,callbackId:o.data.callbackId},o.origin)},handleResponse:(n,e)=>{const i=n.callbackId,t=o.get(i);t&&(o.delete(i),t(n))}}),n.newCommunicationId=()=>`${String.fromCharCode(Date.now()%26+97)}${Math.floor(982451653*Math.random()+982451653).toString(36)}`}(this.WinComm||(this.WinComm={}));\n//# sourceMappingURL=/sm/6f714adc197fd957c2d38a98cdf156db1cecba9b042e767f9036e429c225bd9e.map",
          "meta": "text/javascript"
        }
      },
      {
        "ts": 1704294653067,
        "url": "https://fastly.jsdelivr.net/npm/@violentmonkey/shortcut@1.4.1/dist/index.min.js",
        "data": {
          "content": "/**\n * Minified by jsDelivr using Terser v5.19.2.\n * Original file: /npm/@violentmonkey/shortcut@1.4.1/dist/index.js\n *\n * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files\n */\n/*! @violentmonkey/shortcut v1.4.1 | ISC License */\nwindow.def107=()=>console.log(107);\n//# sourceMappingURL=/sm/ccebd220196b38df0a844cb17cf78a65f77adf1607c33c788081f66ca9559de9.map",
          "meta": "text/javascript"
        }
      }

    ]
  }

  for (let idx = 0; idx < hardcodeScriptEntries.length; idx++) {
    hardcodeScriptEntries[idx].position = idx + 1;
    hardcodeScriptEntries[idx].positionof = hardcodeScriptEntries.length;
  }


  const getListOfUserScripts = () => {
    return JSON.parse(JSON.stringify(hardcodeScriptEntries)).filter((e => e.userscript));
  };

  async function doSave(o) {

    await Promise.resolve(0);

    const { name, uuid: i, src, ask, external, save, force_meta } = o;

    const sourceScript = getScriptByUUID(i);

    if (!sourceScript) return false;

    let nObject = Object.assign({

    }, sourceScript, {

      name: o.name,
      uuid: o.uuid,

      code: o.src,
      header: o.src.split('==/UserScript==').length >= 1 ? (o.src.split('==/UserScript==')[0] + '==/UserScript==') : ''

    });

    if (force_meta && force_meta.lastModified) nObject.lastModified = force_meta.lastModified;

    hardcodeScriptEntries.forEach((entry, idx) => {
      (entry.uuid === nObject.uuid) ? (hardcodeScriptEntries[idx] = nObject) : 0;
    });



  }


  const getScriptByUUID = (wScriptId) => {

    const scripts = hardcodeScriptEntries.filter(e => e.uuid === wScriptId && e.userscript === true);

    const script = scripts.length === 1 && typeof scripts[0].code === 'string' ? scripts[0] : null;

    return script;

  }


  const _d = {
    getStorageByUid(i) {

      return hardcodeStorages[i] || null;

    },
    setStorageByUidAndNotify(uuid, timestamp, n, field, value, toDelete) {

      const entry = hardcodeStorages[uuid]
      if (entry) {
        entry.ts = timestamp;
        if (toDelete) {
          delete entry.data[field];
        } else {
          entry.data[field] = value;
        }
      } else {
        return false;
      }

    },

    getSourceCond(script) {
      if (!script) return null;
      return {
        "inc": [],
        "match": [
          script.matches
        ],
        "exc": []
      }
    }


  }



  const to = {
    async getElement(uuid, eURL) {

      const m = hardcodeExtenalScripts[uuid];
      if (!m || !m.length) return null;
      let w = m.filter(e => e.url === eURL);
      await Promise.resolve();
      if (w && w.length === 1) {
        return w[0];
      }
      return null;


    },

    async updateElement(uuid, eURL, o) {
      const storedValue = await to.getElement(uuid, eURL);
      if (!storedValue) return false;
      const storedMeta = storedValue.data.meta || "text/javascript";
      await to.setElement(uuid, eURL, {
        ...o,
        meta: storedMeta,
      }, true);
      return true;
    },

    async setElement(uuid, eURL, o) { // text/javascript

      const { content: code, meta, lastModified: timestamp } = o;

      if (!hardcodeExtenalScripts[uuid]) return false;
      let w = hardcodeExtenalScripts[uuid].filter(e => e.url === eURL);
      await Promise.resolve();
      if (w && w.length === 1) {
        const entry = w[0];
        entry.ts = timestamp;
        if (entry.data) {
          entry.data.content = code;
          entry.data.meta = meta;
        }
        return true;
      }
      return false;

    }
  }



  return {
    getListOfUserScripts, doSave, getScriptByUUID, ..._d, ...to
  }


})();

// ======================================================================================

const xe = e => {
  const t = (typeof e)[0];
  if ("o" === t)
    try {
      e = t + JSON.stringify(e)
    } catch (n) {
      console.error("Storage: setValue ERROR: " + n.message),
        e = t + JSON.stringify({})
    }
  else
    e = t + e;
  return e
}

function textToStorageEntries(valFileContent) {
  return Object.entries(JSON.parse(valFileContent)).reduce(((e, [t, n]) => {
    e[t] = xe(n);
    return e;
  }), {});
}

function storageUpdateRT(r, t, z) {

  const { wScriptId, valTimestamp } = z;

  const rq2 = Object.keys(r);
  const tq2 = Object.keys(t);
  const tq1 = t;
  const rq1 = r;

  rq2.concat(tq2).filter(((e, t, n) => n.lastIndexOf(e) === t)).forEach((o => {
    rq2.includes(o) ? tq2.includes(o) ? rq1[o] !== tq1[o] && ((t, n, r) => {
      MQ.setStorageByUidAndNotify(wScriptId, valTimestamp, void 0, t, r)
    })(o, tq1[o], rq1[o]) : ((t, n) => {
      MQ.setStorageByUidAndNotify(wScriptId, valTimestamp, void 0, t, n)
    })(o, rq1[o]) : (t => {
      MQ.setStorageByUidAndNotify(wScriptId, valTimestamp, void 0, t, void 0, true)
    })(o, tq1[o])
  }));
}

async function doSaveByExternal(o, lastModified) {
  const m = lastModified ? {
    force_meta: {
      lastModified
    }
  } : {};
  return await MQ.doSave({
    ...o,
    external: true,
    save: true,
    ...m
  })
}


const getCurLastModified = async (wScriptId, wFileType, eURL) => {

  let curLastModified;
  if ("storage" === wFileType) {
    const storage = MQ.getStorageByUid(wScriptId);
    if (storage && storage.ts) curLastModified = storage.ts;
  } else if ("source" === wFileType) {
    const sourceScript = MQ.getScriptByUUID(wScriptId);
    if (!sourceScript) return false;
    const sourceCond = MQ.getSourceCond(sourceScript);
    if (!sourceCond) return false;
    curLastModified = sourceScript.lastModified
  } else if (eURL) { // external
    const t = await MQ.getElement(wScriptId, eURL);
    if (t) {
      curLastModified = t.ts;
    }
  }

  return curLastModified;

}

const getStoredContent = async (wScriptId, wFileType, eURL) => {

  let storedValue;
  if ("source" === wFileType) {
    const sourceScript = MQ.getScriptByUUID(wScriptId);
    storedValue = sourceScript ? sourceScript.code : '';
  } else if ("storage" === wFileType) {
    const storage = MQ.getStorageByUid(wScriptId);
    if (storage) storedValue = storage.data;
  } else if ("external" === wFileType) {
    const element = await MQ.getElement(wScriptId, eURL);
    if (element) storedValue = element.data.content;
  }
  if (void 0 === storedValue) {
    return false;
  }
  if ("string" == typeof storedValue) {
    resFileText = storedValue;
  } else {
    resFileText = storageObjectToText(storedValue);
  }

  return resFileText;

}

// Generates a universally unique identifier (UUID)
const generateUUID = () => {
  const uuidTemplate = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";
  return uuidTemplate.replace(/[xy]/g, (char) => {
    const randomHexDigit = Math.floor(16 * Math.random()) | 0;
    const value = (char === 'x') ? randomHexDigit : (randomHexDigit & 0x3 | 0x8);
    return value.toString(16);
  });
};

// Parses a stored value based on its prefix
const parseStoredValue = (storedValue, defaultValue) => {
  if (!storedValue) {
    return defaultValue;
  }
  
  const valueType = storedValue.charAt(0);
  const value = storedValue.substring(1);

  switch (valueType) {
    case 'b':
      return value === 'true';
    case 'n':
      return Number(value);
    case 'o':
      try {
        return JSON.parse(value);
      } catch (error) {
        console.error('Storage: getValue ERROR: ' + error.message);
        return defaultValue;
      }
    case 'x':
      try {
        return decodeURIComponent(escape(atob(value)));
      } catch (error) {
        return value;
      }
    default:
      return value;
  }
};

const rndUID = crypto.randomUUID();

async function sha1Hex(message) {
  const msgUint8 = new TextEncoder().encode(message); // encode as (utf-8) Uint8Array
  const hashBuffer = await crypto.subtle.digest("SHA-1", msgUint8); // hash the message
  const hashArray = Array.from(new Uint8Array(hashBuffer)); // convert buffer to byte array
  const hashHex = hashArray
    .map((b) => b.toString(16).padStart(2, "0"))
    .join(""); // convert bytes to hex string
  return hashHex;
}

const storageObjectToText = (e) => {

  const n = {};
  Object.keys(e).forEach((t => {
    n[t] = parseStoredValue(e[t])
  }));
  const tpz = `__undefined__${generateUUID()}`;
  const replacer = ((e, n) => void 0 === n ? tpz : n);
  return JSON.stringify(n, replacer, void 0).replace(new RegExp(`"${tpz}"`, "g"), "undefined");


}

const convertResourcePath = (reqFilePath) => {
  return reqFilePath.split("/").map((e => decodeURIComponent(e)));
}

// ======================================================================================


const USE_LIST_VERSION_2 = true;
const onRequest = async (port, reqData, requesterInfo, responseFn) => { // WebCoder_Extensions
  if (!port)
    throw Error("invalid port");
  const { action: reqAction, messageId: reqMsgId } = reqData
    , onError931 = (e, t, n) => responseFn({
      messageId: e,
      error: {
        number: t,
        message: n
      }
    });

  const getToken = () => sha1Hex(`#${rndUID}#${requesterInfo.url}#${reqData.connectionId}`);
  const isAllowed = (reqData, requesterInfo) => {
    // implement own logic to deny attacks from untrustworthy extensions
    return typeof (requesterInfo.id || 0) === 'string' && (requesterInfo.url || '').includes(`://${requesterInfo.id}/background.`);
  };

  async function isTokenFailed(reqData, requesterInfo) {
    const token = await getToken(requesterInfo);
    return (token) !== (reqData.access_token || 0);
  }

  try {
    if ("options" == reqAction) { // initial loading
      if (isAllowed(reqData, requesterInfo)) {

        const token = await getToken(requesterInfo);
        responseFn({
          messageId: reqMsgId,
          allow: ["options", "list", "get", "patch"],
          access_token: token
        });
      }
    } else if ("list" == reqAction) { // get the list of files
      if (await isTokenFailed(reqData, requesterInfo)) return onError931(reqMsgId, 403, "Forbidden (Token Incorrect)");
      const listOfUserScripts = MQ.getListOfUserScripts();

      let responseData;
      if (USE_LIST_VERSION_2) {


        const files = [];

        for (const script of listOfUserScripts) {
          const o = `${encodeURIComponent(script.uuid)}`; // ce6a2ec5-fb09-4de9-853a-e0a70c5da20e
          files.push({
            name: "script.user.js",
            unders: [script.namespace || "", script.name],
            path: `${o}/source`
          });
          if (script.storage_key_count > 0) {
            files.push({
              name: "storage.json",
              unders: [script.namespace || "", script.name],
              path: `${o}/storage`
            });
          }
          if ((script.requires || 0).length > 0) {
            for (const external of script.requires) {
              files.push({
                name: external.url,
                unders: [script.namespace || "", script.name, "external"],
                path: `${o}/external/${encodeURIComponent(external.url)}`
              });
            }
          }
        }

        responseData = {
          version: 2,
          messageId: reqMsgId,
          files
        };

      } else {

        const list = listOfUserScripts.map((script => {
          const o = `${encodeURIComponent(script.uuid)}`; // ce6a2ec5-fb09-4de9-853a-e0a70c5da20e
          return {
            namespace: script.namespace || "",
            name: script.name,
            path: `${o}/source`, // "source" === r ? "script.user.js"
            requires: script.requires.filter((e => e.url)).map((e => `${o}/external/${encodeURIComponent(e.url)}`)),
            storage: script.storage_key_count ? `${o}/storage` : void 0 //  "storage" === r ? "storage.json"
          }
        }));

        responseData = {
          version: 1,
          messageId: reqMsgId,
          list
        };

      }

      responseFn(responseData);
    } else if ("get" == reqAction) { // reading action
      if (await isTokenFailed(reqData, requesterInfo)) return onError931(reqMsgId, 403, "Forbidden (Token Incorrect)");
      const valIfNotModifiedSince = reqData.ifNotModifiedSince;
      const [wScriptId, wFileType, eURL] = convertResourcePath(reqData.path);
      if (!["source", "storage", "external"].includes(wFileType)) {
        return onError931(reqMsgId, 404, "Not found");
      }
      try {
        const curLastModified = await getCurLastModified(wScriptId, wFileType, eURL);
        if (curLastModified === false) return onError931(reqMsgId, 404, "Not found");
        let resFileText;
        if (!valIfNotModifiedSince || !curLastModified || curLastModified > valIfNotModifiedSince) {
          resFileText = await getStoredContent(wScriptId, wFileType, eURL);
          if (resFileText === false) return onError931(reqMsgId, 404, "Not found");
        }
        if (typeof resFileText !== "string") {
          resFileText = "";
        }
        responseFn({
          messageId: reqMsgId,
          value: resFileText,
          lastModified: curLastModified
        });
      } catch (e) {
        return onError931(reqMsgId, 404, "Not found")
      }
    } else if ("patch" === reqAction) { // saving action
      if (await isTokenFailed(reqData, requesterInfo)) return onError931(reqMsgId, 403, "Forbidden (Token Incorrect)");
      const {
        value: valFileContent,
        lastModified: valLastModified6
      } = reqData;
      const [wScriptId, wFileType, eURL] = convertResourcePath(reqData.path);
      if (!wScriptId || "string" != typeof valFileContent) return onError931(reqMsgId, 400, "Bad Request");
      const sourceScript = MQ.getScriptByUUID(wScriptId);
      if (!sourceScript) return onError931(reqMsgId, 404, "Not found");
      const sourceCond = MQ.getSourceCond(sourceScript);
      if (!sourceCond) return onError931(reqMsgId, 404, "Not found");
      if ("source" == wFileType) {
        if (void 0 !== eURL) return onError931(reqMsgId, 400, "Bad Request");
        const res = await doSaveByExternal({
          name: sourceScript.name,
          uuid: wScriptId,
          src: valFileContent
        }, valLastModified6);
        if (res === false) return onError931(reqMsgId, 400, "Bad Request");
      } else if ("storage" == wFileType) {
        if (void 0 !== eURL) return onError931(reqMsgId, 400, "Bad Request");
        const valTimestamp = valLastModified6 || Date.now();
        try {
          const storage = MQ.getStorageByUid(wScriptId);
          const curData = storage ? storage.data : undefined;
          if (curData === void 0) return onError931(reqMsgId, 400, "Bad Request");
          const newData = textToStorageEntries(valFileContent);
          storageUpdateRT(newData, curData, { wScriptId, valTimestamp }); // r: new ; t: old
        } catch (e) {
          return onError931(reqMsgId, 400, "Bad Request")
        }
      } else {
        if ("external" != wFileType) return onError931(reqMsgId, 404, "Not found");
        if (!eURL) return onError931(reqMsgId, 404, "Not found");
        const res = await MQ.updateElement(wScriptId, eURL, {
          content: valFileContent,
          lastModified: valLastModified6
        });
        if (res === false) return onError931(reqMsgId, 404, "Not found");
      }
      responseFn({
        messageId: reqMsgId
      })
    } else {
      if (await isTokenFailed(reqData, requesterInfo)) return onError931(reqMsgId, 403, "Forbidden (Token Incorrect)");
      if ("put" === reqAction || "delete" == reqAction) return onError931(reqMsgId, 405, "Method Not Allowed");
      port.disconnect();
    }
  } catch (e) {
    return onError931(reqMsgId, 500, "Internal error")
  }
}

chrome.runtime.onConnectExternal.addListener(function (port) {
  const lastError = chrome.runtime.lastError;
  if (lastError) lastError.valueOf();

  console.log('Connected by the external', port.sender);
  port.onMessage.addListener(function (msg, port) {
    const lastError = chrome.runtime.lastError;
    if (lastError) lastError.valueOf();
    console.log('incoming message from External', msg);

    if (msg && void 0 !== msg.method) {
      let data = port.sender;
      let module = data.id;
      if (!(msg && msg.method === 'userscripts')) {
        return void port.disconnect();
      }
      let result = onRequest(port, msg, data, function (m) {

        console.log('outgoing message to External', m)
        try {
          port.postMessage(m);
        } catch (e) {
          console.warn(e);
        }
      });
      if ("function" == typeof result) {
        port.onDisconnect.addListener((port) => {
          const lastError = chrome.runtime.lastError;
          if (lastError) lastError.valueOf();
          result(port);
        });
      }
    }


  });
});
console.log('done');
